name: Build Slack Package

on:
  workflow_dispatch: # Allows manual triggering of the workflow

jobs:
  build:
    runs-on: macos-latest # Specifies that this job runs on a macOS runner

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Show current working directory and recipes folder for debug
        # Display current directory and contents of the 'recipes' folder for debugging purposes.
        run: |
          echo "Current working directory:"
          pwd
          echo "Repository root contents:"
          ls -la
          echo "Recipes folder contents:"
          ls -la ./recipes || true # Add || true to prevent failure if folder is empty or not found

      - name: Clean AutoPkg cached recipe repositories
        # Remove old AutoPkg recipe caches to ensure a clean slate and avoid conflicts.
        run: |
          echo "Removing old AutoPkg recipe caches..."
          rm -rf ~/Library/AutoPkg/RecipeRepos/* || true # Use || true to prevent failure if directory doesn't exist
          echo "Cache cleanup done."

      - name: Download and install AutoPkg
        # Download the AutoPkg installer package.
        run: |
          echo "Downloading AutoPkg installer..."
          curl -L -o autopkg.pkg https://github.com/autopkg/autopkg/releases/download/v2.7.5/AutoPkg-2.7.5.pkg

          if [ ! -f autopkg.pkg ]; then
            echo "Error: AutoPkg installer package missing!"
            exit 1
          fi

          # Verify the downloaded file size to ensure it's not a partial download or error page.
          filesize=$(stat -f%z autopkg.pkg)
          echo "Installer package size: $filesize bytes"

          if [ "$filesize" -lt 100000 ]; then # Minimum expected size for a valid installer
            echo "Error: Installer package is suspiciously small; aborting."
            exit 1
          fi

          # Install AutoPkg silently.
          echo "Installing AutoPkg..."
          sudo installer -pkg autopkg.pkg -target /
          echo "AutoPkg version:"
          autopkg version

      - name: Add AutoPkg recipe repositories
        # Add the official AutoPkg recipes repository. This contains many common app recipes, including Slack.
        run: |
          echo "Adding official AutoPkg recipes repo..."
          autopkg repo-add https://github.com/autopkg/recipes.git

          # Note: No need to explicitly add './recipes' if your custom recipes are meant to be found
          # by AutoPkg's default search path (current working directory and its subfolders).
          # If you have custom processors, ensure AUTO_PKG_PROCESSOR_PATHS is set correctly.

          echo "Listing all recipes to confirm..."
          autopkg list-recipes

      - name: Set environment variable for custom processors (if any)
        # Set an environment variable if you have custom AutoPkg processors in your 'processors' folder.
        run: |
          echo "AUTO_PKG_PROCESSOR_PATHS=$(pwd)/processors" >> $GITHUB_ENV

      - name: Run Slack.download.recipe with verbose output
        # Execute the Slack.download.recipe. This recipe will download the latest Slack.app DMG
        # and place it into AutoPkg's cache directory.
        run: autopkg run Slack.download.recipe --verbose

      - name: Mount DMG and Extract Slack.app
        id: extract_app
        run: |
          RECIPE_CACHE_DIR="$HOME/Library/AutoPkg/Cache"
          SLACK_DOWNLOAD_DIR="$RECIPE_CACHE_DIR/com.architrave.download.Slack/downloads"
          SLACK_DMG_PATH=$(find "$SLACK_DOWNLOAD_DIR" -name "Slack.dmg" -type f | head -n 1)

          if [ -z "$SLACK_DMG_PATH" ]; then
            echo "::error ::Slack.dmg not found in $SLACK_DOWNLOAD_DIR."
            echo "Contents of $SLACK_DOWNLOAD_DIR for debugging:"
            ls -la "$SLACK_DOWNLOAD_DIR" || true
            exit 1
          fi

          echo "Found Slack DMG: $SLACK_DMG_PATH"
          
          # Mount the DMG to a unique temporary mount point to avoid conflicts
          TEMP_MOUNT_POINT="/private/tmp/SlackMount_$(uuidgen)"
          mkdir -p "$TEMP_MOUNT_POINT" # Create the mount point directory
          
          DMG_MOUNT_OUTPUT=$(hdiutil attach "$SLACK_DMG_PATH" -nobrowse -mountpoint "$TEMP_MOUNT_POINT" 2>&1 || true)
          # Verify mount point explicitly captured from hdiutil output
          MOUNT_POINT=$(echo "$DMG_MOUNT_OUTPUT" | grep "$TEMP_MOUNT_POINT" | awk '{print $NF}')

          if [ -z "$MOUNT_POINT" ]; then
            echo "::error ::Failed to mount Slack DMG. Full hdiutil attach output:"
            echo "$DMG_MOUNT_OUTPUT"
            rmdir "$TEMP_MOUNT_POINT" || true # Clean up empty mount point if failed
            exit 1
          fi
          echo "Mounted DMG at: $MOUNT_POINT"

          # Define target directory for extracted app (inside the recipe's cache folder for persistence)
          EXTRACTED_APP_DIR="$RECIPE_CACHE_DIR/com.architrave.download.Slack/extracted_app"
          mkdir -p "$EXTRACTED_APP_DIR"
          echo "Target extraction directory: $EXTRACTED_APP_DIR"
          
          # Copy the .app bundle from the mounted DMG to the extracted_app directory
          SLACK_APP_SOURCE="$MOUNT_POINT/Slack.app"
          if [ ! -d "$SLACK_APP_SOURCE" ]; then
            echo "::error ::Slack.app not found inside mounted DMG at $SLACK_APP_SOURCE. Contents of mount point:"
            ls -la "$MOUNT_POINT" || true # List contents for debugging
            exit 1
          fi
          
          echo "Copying Slack.app from '$SLACK_APP_SOURCE' to '$EXTRACTED_APP_DIR/'..."
          cp -R "$SLACK_APP_SOURCE" "$EXTRACTED_APP_DIR/"
          
          # Verify copy operation
          if [ ! -d "$EXTRACTED_APP_DIR/Slack.app" ]; then
              echo "::error ::Failed to copy Slack.app to $EXTRACTED_APP_DIR/Slack.app."
              ls -la "$EXTRACTED_APP_DIR" || true # Show contents of target dir if copy failed
              exit 1
          fi

          echo "Copied Slack.app successfully to: $EXTRACTED_APP_DIR/Slack.app"
          ls -la "$EXTRACTED_APP_DIR" # Show contents of extracted app dir for confirmation
          
          # Set the path to the extracted app as an environment variable for subsequent steps
          echo "SLACK_APP_PATH=$EXTRACTED_APP_DIR/Slack.app" >> $GITHUB_ENV
          echo "SLACK_APP_PATH is now set to: $SLACK_APP_PATH" # Debug output
          echo "MOUNT_POINT=$MOUNT_POINT" >> $GITHUB_OUTPUT # Export mount point for unmount step

      - name: Unmount Slack DMG
        # This step ensures the DMG is detached even if subsequent steps fail.
        if: always() && steps.extract_app.outputs.MOUNT_POINT # Only run if a mount point was successfully set
        run: |
          MOUNT_POINT="${{ steps.extract_app.outputs.MOUNT_POINT }}"
          if [ -n "$MOUNT_POINT" ]; then
            echo "Unmounting DMG at: $MOUNT_POINT"
            hdiutil detach "$MOUNT_POINT" -quiet || true # Use || true to prevent failure on already unmounted
          else
            echo "No DMG mount point found to detach."
          fi

      - name: Debug - List all files in AutoPkg Cache Directory
        # This debug step lists the contents of the AutoPkg cache directory.
        # It helps verify that the Slack.app was downloaded and processed correctly.
        run: |
          # Directly use the standard AutoPkg Cache Directory path.
          RECIPE_CACHE_DIR="$HOME/Library/AutoPkg/Cache"
          
          if [ -z "$RECIPE_CACHE_DIR" ]; then
            echo "Error: AutoPkg CacheDir is empty or could not be determined."
            exit 1
          fi

          echo "AutoPkg Cache Directory: $RECIPE_CACHE_DIR"
          
          if [ ! -d "$RECIPE_CACHE_DIR" ]; then
            echo "Error: AutoPkg Cache Directory does not exist: $RECIPE_CACHE_DIR"
          fi

          echo "Listing directory contents (might be empty if recipe just ran):"
          ls -la "$RECIPE_CACHE_DIR" || true # '|| true' allows the step to pass even if the directory is empty
          echo "Listing all files recursively:"
          find "$RECIPE_CACHE_DIR" -type f -o -type d || true # '|| true' allows the step to pass even if no files are found

      - name: Find downloaded Slack.app artifact # This step is now primarily for verification
        id: find-slack-app # Assign an ID to this step to reference its outputs later
        # Verify the presence of the extracted Slack.app bundle.
        run: |
          # The SLACK_APP_PATH is already set by the 'Mount DMG and Extract Slack.app' step.
          # This step just confirms its existence for clarity in the logs.
          if [ -z "${{ env.SLACK_APP_PATH }}" ]; then
            echo "::error ::SLACK_APP_PATH environment variable not set. Extraction likely failed."
            exit 1
          fi
          if [ ! -d "${{ env.SLACK_APP_PATH }}" ]; then
            echo "::error ::Extracted Slack.app directory does not exist at ${{ env.SLACK_APP_PATH }}."
            exit 1
          fi
          echo "Confirmed Slack.app exists at: ${{ env.SLACK_APP_PATH }}"
          
          # No need to set SLACK_APP_PATH again, but we can set an output indicating success
          echo "app_found=true" >> $GITHUB_OUTPUT

      - name: Extract Bundle ID and Version for Intune
        id: extract-info # Assign an ID to this step to reference its outputs later
        # Use PlistBuddy to extract the Bundle ID and Version from the Slack.app's Info.plist.
        run: |
          # Ensure SLACK_APP_PATH is available from environment
          if [ -z "${{ env.SLACK_APP_PATH }}" ]; then
            echo "::error ::SLACK_APP_PATH environment variable is missing for Info.plist extraction."
            exit 1
          fi

          INFO_PLIST_PATH="${{ env.SLACK_APP_PATH }}/Contents/Info.plist"
          
          if [ ! -f "$INFO_PLIST_PATH" ]; then
            echo "::error ::Info.plist not found for Slack.app at $INFO_PLIST_PATH"
            exit 1
          fi

          BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$INFO_PLIST_PATH")
          APP_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$INFO_PLIST_PATH")

          echo "Extracted Bundle ID: $BUNDLE_ID"
          echo "Extracted App Version: $APP_VERSION"

          # Create a text file with Intune-relevant information.
          INFO_FILE="slack_intune_info.txt"
          echo "--- Slack Intune Details ---" > "$INFO_FILE"
          echo "Bundle ID (for Detection Rules): $BUNDLE_ID" >> "$INFO_FILE"
          echo "Version (for Display/Detection): $APP_VERSION" >> "$INFO_FILE"
          echo "" >> "$INFO_FILE"
          echo "Common Install Command (if repackaged as PKG): sudo installer -pkg <package_name>.pkg -target /" >> "$INFO_FILE"
          echo "Common Uninstall Command: /bin/rm -rf '/Applications/Slack.app'" >> "$INFO_FILE"
          echo "----------------------------" >> "$INFO_FILE"

          echo "Intune info saved to $INFO_FILE"
          ls -la "$INFO_FILE" # Show the created file in logs

          # Make the path to the info file available as a step output for artifact upload.
          echo "INFO_FILE=$INFO_FILE" >> $GITHUB_OUTPUT

      - name: Upload the Slack.app bundle as artifact
        # Upload the Slack.app bundle as a workflow artifact. GitHub will automatically zip this directory.
        uses: actions/upload-artifact@v4
        with:
          name: slack-app-bundle # Name of the artifact
          path: ${{ env.SLACK_APP_PATH }} # Path to the Slack.app bundle
          retention-days: 7 # How long to keep the artifact

      - name: Upload Intune info file as artifact
        # Upload the text file containing Bundle ID and Version as a separate artifact.
        uses: actions/upload-artifact@v4
        with:
          name: slack-intune-info # Name of the artifact
          path: ${{ steps.extract-info.outputs.INFO_FILE }} # Path to the info text file
          retention-days: 7 # How long to keep the artifact

name: Slack Desktop (Windows) Intune MSIX Package

on:
  workflow_dispatch: # Allows manual triggering of the workflow

jobs:
  package-slack-msix: # Renamed job to reflect MSIX packaging
    runs-on: windows-latest # This job runs on a Windows runner

    steps:
      - name: ‚¨áÔ∏è Checkout repository
        uses: actions/checkout@v4 # Check out your repository code

      - name: üìÇ Create working directories
        shell: pwsh
        run: |
          Write-Host "Creating necessary directories..."
          New-Item -ItemType Directory -Path ".\input" -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path ".\output" -ErrorAction SilentlyContinue
          Write-Host "Directories created."

      - name: üì• Download Slack MSIX installer
        shell: pwsh
        run: |
          # Option 1 (Recommended): Use Slack's official MSIX download link.
          # This URL is designed to trigger an MSIX download from Slack's servers.
          # It should handle redirects correctly, but verify its behavior.
          $msixUrl = "https://slack.com/downloads/instructions/windows?ddl=1&build=win64_msix"
          
          # Option 2 (Alternative): If you have the MSIX stored in a secure, accessible location (e.g., Azure Blob Storage, internal file share)
          # Replace the URL below with your actual direct download link if you host it.
          # Example: $msixUrl = "https://your-company-storage.com/path/to/Slack-win64.msix"
          
          # Option 3 (Less Ideal for Binaries, but viable): If you commit the MSIX directly to your GitHub repository
          # You would comment out this entire 'Download Slack MSIX installer' step and
          # ensure the MSIX is committed to '.\input\slack-desktop-win64.msix'
          # A subsequent step would then just verify its presence, not download it.

          $outputFile = ".\input\slack-desktop-win64.msix" # Naming it directly as .msix
          Write-Host "Downloading Slack MSIX from $msixUrl to $outputFile..."
          try {
            Invoke-WebRequest -Uri $msixUrl -OutFile $outputFile -MaximumRedirection 5
            
            if (-not (Test-Path $outputFile)) {
              throw "Downloaded file not found at $outputFile."
            }
            # Verify the file is an MSIX (or similar package type)
            if ((Get-Item $outputFile).Extension -notin @(".msix", ".appx", ".appxbundle")) {
              Write-Warning "Downloaded file does not have a typical MSIX/APPX extension. Please verify."
            }
            $fileSize = (Get-Item $outputFile).Length
            Write-Host "Installer package size: $fileSize bytes."
            if ($fileSize -lt 10000000) { # Adjust minimum expected size for an MSIX package
              Write-Warning "Warning: Downloaded MSIX package is suspiciously small; please verify the download."
            }
            Write-Host "‚úÖ Slack MSIX installer downloaded successfully."
          } catch {
            Write-Error "‚ùå Failed to download Slack MSIX installer: $($_.Exception.Message)"
            exit 1
          }

      - name: üîé Get Slack MSIX version
        id: get_version
        shell: pwsh
        run: |
          $path = ".\input\slack-desktop-win64.msix"
          if (-not (Test-Path $path)) { # Added robustness check
            Write-Error "‚ùå Slack MSIX installer not found for version extraction."
            exit 1
          }
          
          # Simplified version extraction from filename (common for downloaded packages)
          $fileName = (Get-Item $path).BaseName
          $version = ""
          if ($fileName -match "slack-(\d+\.\d+\.\d+\.\d+)") { # Match typical MSIX version format
              $version = $Matches[1]
              Write-Host "Detected version from filename: $version"
          } elseif ($fileName -match "(\d+\.\d+\.\d+\.\d+)") { # General version pattern
              $version = $Matches[1]
              Write-Host "Detected version from filename (generic): $version"
          } else {
              Write-Warning "Could not reliably extract version from MSIX filename. Using 'Unknown'."
              $version = "Unknown"
          }

          # Set SLACK_VERSION as an environment variable for subsequent steps
          echo "SLACK_VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "‚úÖ Detected Slack MSIX version: $version" # Re-added Write-Host

      - name: üì¶ Rename Slack MSIX package
        shell: pwsh
        run: |
          $originalFile = ".\input\slack-desktop-win64.msix"
          $outputFolder = ".\output"
          $slackVersion = $env:SLACK_VERSION

          # Add a check for 'Unknown' version to prevent invalid filenames
          if ($slackVersion -eq "Unknown") {
              Write-Error "‚ùå Cannot rename package: Slack version could not be reliably extracted. Please check the download URL or filename pattern."
              exit 1
          }

          if (-not (Test-Path $originalFile)) { # Added robustness check
              Write-Error "‚ùå Slack MSIX package not found for moving and renaming."
              exit 1
          }

          $newName = "Slack-win-x64-${slackVersion}.msix"
          $destinationPath = "$outputFolder\$newName"

          Write-Host "Moving and renaming '$originalFile' to '$destinationPath'..."
          # FIX: Use Move-Item when changing directory and renaming simultaneously
          Move-Item -Path $originalFile -Destination $destinationPath -Force

          $msixPackagePath = $destinationPath
          Write-Host "‚úÖ Slack MSIX package prepared successfully: $msixPackagePath" # Re-added Write-Host
          echo "SLACK_MSIX_PACKAGE_PATH=$msixPackagePath" | Out-File -FilePath $env:GITHUB_ENV -Append # Set as env var

      # The 'Generate Intune App Details File for MSIX' step and its artifact upload are commented out as requested.

      - name: ‚¨ÜÔ∏è Upload Slack .msix package as artifact
        uses: actions/upload-artifact@v4
        with:
          name: Slack-Intune-MSIX-Package
          path: output\*.msix # Upload the generated .msix file
          retention-days: 7

      - name: üßπ Clean up temporary directories
        if: always() # Run even if previous steps failed
        shell: pwsh
        run: |
          Write-Host "Cleaning up temporary directories..."
          Remove-Item -Path ".\input", ".\output" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "Cleanup complete."
